<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pandora - The Web Organism</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0afb69;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            position: relative;
        }

        .header {
            text-align: center;
            padding: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid #0afb69;
            z-index: 10;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
            z-index: 10;
        }

        .organism-container {
            flex: 1;
            position: relative;
            border: 1px solid #0afb69;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            background: rgba(10, 251, 105, 0.05);
        }

        #organism-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .interaction-panel {
            padding: 15px;
            border: 1px solid #0afb69;
            border-radius: 8px;
            background: rgba(10, 251, 105, 0.05);
            z-index: 10;
        }

        #user-input {
            width: 100%;
            background: #000;
            border: 1px solid #0afb69;
            color: #0afb69;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        #submit-btn {
            background: #000;
            color: #0afb69;
            border: 1px solid #0afb69;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        #submit-btn:hover {
            background: #0afb69;
            color: #000;
        }

        .status-panel {
            margin-top: 15px;
            font-size: 14px;
        }

        .memory-cell {
            display: inline-block;
            width: 10px;
            height: 10px;
            border: 1px solid #0afb69;
            margin: 2px;
            border-radius: 50%;
        }

        .memory-cell.active {
            background: #0afb69;
        }

        .defense-mode {
            animation: shake 0.5s infinite;
            filter: hue-rotate(90deg) brightness(150%);
        }

        .mutation-animation {
            animation: pulse 2s;
        }

        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(0); }
            75% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }

        @keyframes pulse {
            0% { filter: brightness(100%); }
            50% { filter: brightness(200%); }
            100% { filter: brightness(100%); }
        }

        .background-element {
            position: absolute;
            border-radius: 50%;
            opacity: 0.3;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(0) translateX(0); }
            25% { transform: translateY(-20px) translateX(10px); }
            50% { transform: translateY(0) translateX(20px); }
            75% { transform: translateY(20px) translateX(10px); }
            100% { transform: translateY(0) translateX(0); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>PANDORA</h1>
        <p>The World's First Web Organism</p>
    </div>

    <div class="container">
        <div class="organism-container">
            <canvas id="organism-canvas"></canvas>
        </div>
        
        <div class="interaction-panel">
            <input type="text" id="user-input" placeholder="Interact with Pandora...">
            <button id="submit-btn">Interact</button>
            
            <div class="status-panel">
                <p>Generation: <span id="generation">1</span></p>
                <p>Memory: <span id="memory-cells"></span></p>
                <p>Status: <span id="status">Awake and responsive</span></p>
            </div>
        </div>
    </div>

    <script>
        // Organism state and configuration
        const state = {
            generation: 1,
            color: '#0afb69',
            shape: 'circles',
            complexity: 5,
            movement: 1,
            memory: [],
            hostility: 0,
            defenseMode: false,
            growthStage: 0
        };

        // DOM elements
        const canvas = document.getElementById('organism-canvas');
        const ctx = canvas.getContext('2d');
        const userInput = document.getElementById('user-input');
        const submitBtn = document.getElementById('submit-btn');
        const generationEl = document.getElementById('generation');
        const memoryCellsEl = document.getElementById('memory-cells');
        const statusEl = document.getElementById('status');
        const organismContainer = document.querySelector('.organism-container');

        // Initialize the organism
        function init() {
            // Set canvas size
            resizeCanvas();
            
            // Load from localStorage if available
            loadState();
            
            // Apply initial mutation
            mutate();
            
            // Initialize memory display
            updateMemoryDisplay();
            
            // Start animation
            animate();
            
            // Add event listeners
            window.addEventListener('resize', resizeCanvas);
            submitBtn.addEventListener('click', handleInteraction);
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleInteraction();
            });
            
            // Create background elements
            createBackgroundElements();
        }

        // Resize canvas to fit container
        function resizeCanvas() {
            canvas.width = organismContainer.offsetWidth;
            canvas.height = organismContainer.offsetHeight;
        }

        // Load state from localStorage
        function loadState() {
            const savedState = localStorage.getItem('pandoraState');
            if (savedState) {
                const parsed = JSON.parse(savedState);
                Object.assign(state, parsed);
                generationEl.textContent = state.generation;
            }
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('pandoraState', JSON.stringify(state));
        }

        // Mutate the organism on each reload
        function mutate() {
            state.generation++;
            
            // Random mutations
            if (Math.random() > 0.7) {
                state.complexity += Math.floor(Math.random() * 3);
                statusEl.textContent = "Evolving: Complexity increased";
            }
            
            if (Math.random() > 0.7) {
                state.movement += Math.random() * 0.2;
                statusEl.textContent = "Evolving: Movement patterns changed";
            }
            
            if (Math.random() > 0.8) {
                const colors = ['#0afb69', '#ff2e88', '#00ffff', '#ffaa00', '#c24fff'];
                state.color = colors[Math.floor(Math.random() * colors.length)];
                statusEl.textContent = "Evolving: Color shifted";
            }
            
            if (Math.random() > 0.9) {
                const shapes = ['circles', 'triangles', 'squares', 'hexagons', 'fibers'];
                state.shape = shapes[Math.floor(Math.random() * shapes.length)];
                statusEl.textContent = "Evolving: Morphology changed";
            }
            
            // Limit values
            state.complexity = Math.min(state.complexity, 20);
            state.movement = Math.min(state.movement, 3);
            
            generationEl.textContent = state.generation;
            organismContainer.classList.add('mutation-animation');
            setTimeout(() => {
                organismContainer.classList.remove('mutation-animation');
            }, 2000);
            
            saveState();
        }

        // Handle user interaction
        function handleInteraction() {
            const input = userInput.value.trim();
            if (input === '') return;
            
            // Check for hostile input
            if (isHostile(input)) {
                handleHostileInput();
            } else {
                // Normal interaction
                state.memory.push(input);
                if (state.memory.length > 100) state.memory.shift(); // Limit memory size
                
                statusEl.textContent = `Learning: "${input.substring(0, 15)}${input.length > 15 ? '...' : ''}"`;
                state.growthStage = Math.min(state.growthStage + 0.1, 1);
                
                // Occasionally evolve from positive interactions
                if (Math.random() > 0.8) {
                    mutate();
                    statusEl.textContent = "Evolving from interaction!";
                }
            }
            
            userInput.value = '';
            updateMemoryDisplay();
            saveState();
        }

        // Check if input is hostile
        function isHostile(input) {
            const hostilePatterns = [
                /<script>/i,
                /javascript:/i,
                /onerror=/i,
                /onload=/i,
                /alert\(/i,
                /eval\(/i,
                /document\.cookie/i,
                /localStorage/i,
                /sessionStorage/i,
                /window\.location/i,
                /debugger;/i,
                /<!--/i,
                /\/\*/i,
                /DROP TABLE/i,
                /UNION SELECT/i,
                /DELETE FROM/i,
                /INSERT INTO/i,
                /SELECT \* FROM/i
            ];
            
            return hostilePatterns.some(pattern => pattern.test(input));
        }

        // Handle hostile input
        function handleHostileInput() {
            state.hostility++;
            statusEl.textContent = "Defense mode activated!";
            
            // Activate defense mode
            state.defenseMode = true;
            document.body.classList.add('defense-mode');
            
            // Clear the hostile input
            userInput.value = '';
            
            // Add to memory with warning
            state.memory.push("WARNING: Hostile input blocked");
            if (state.memory.length > 100) state.memory.shift();
            
            // Gradually recover from defense mode
            setTimeout(() => {
                state.defenseMode = false;
                document.body.classList.remove('defense-mode');
                statusEl.textContent = "Awake and responsive";
            }, 3000);
            
            updateMemoryDisplay();
            saveState();
        }

        // Update memory visualization
        function updateMemoryDisplay() {
            memoryCellsEl.innerHTML = '';
            const displayCount = Math.min(state.memory.length, 20);
            
            for (let i = 0; i < 20; i++) {
                const cell = document.createElement('div');
                cell.className = 'memory-cell';
                if (i < displayCount) {
                    cell.classList.add('active');
                }
                memoryCellsEl.appendChild(cell);
            }
        }

        // Create floating background elements
        function createBackgroundElements() {
            for (let i = 0; i < 20; i++) {
                const el = document.createElement('div');
                el.className = 'background-element';
                
                // Random properties
                const size = Math.random() * 50 + 10;
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                const hue = Math.random() * 360;
                const delay = Math.random() * 20;
                
                el.style.width = `${size}px`;
                el.style.height = `${size}px`;
                el.style.left = `${posX}%`;
                el.style.top = `${posY}%`;
                el.style.background = `hsl(${hue}, 70%, 50%)`;
                el.style.animationDelay = `-${delay}s`;
                
                document.body.appendChild(el);
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw based on current state
            drawOrganism();
        }

        // Draw the organism based on its current state
        function drawOrganism() {
            const time = Date.now() * 0.001;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const size = Math.min(canvas.width, canvas.height) * 0.3 * (1 + state.growthStage);
            
            ctx.save();
            
            if (state.defenseMode) {
                // Distorted appearance in defense mode
                ctx.filter = 'hue-rotate(90deg) brightness(150%)';
            }
            
            // Draw based on current shape
            switch (state.shape) {
                case 'circles':
                    drawCircles(time, centerX, centerY, size);
                    break;
                case 'triangles':
                    drawTriangles(time, centerX, centerY, size);
                    break;
                case 'squares':
                    drawSquares(time, centerX, centerY, size);
                    break;
                case 'hexagons':
                    drawHexagons(time, centerX, centerY, size);
                    break;
                case 'fibers':
                    drawFibers(time, centerX, centerY, size);
                    break;
            }
            
            ctx.restore();
        }

        // Different drawing methods for different shapes
        function drawCircles(time, centerX, centerY, size) {
            const complexity = state.complexity;
            const movement = state.movement;
            
            for (let i = 0; i < complexity; i++) {
                const angle = (i / complexity) * Math.PI * 2 + time * movement * 0.2;
                const radius = size * (0.3 + 0.7 * (i / complexity));
                const x = centerX + Math.cos(angle) * radius * 0.5;
                const y = centerY + Math.sin(angle) * radius * 0.5;
                
                const circleSize = size * (0.1 + 0.05 * Math.sin(time + i));
                
                ctx.beginPath();
                ctx.arc(x, y, circleSize, 0, Math.PI * 2);
                ctx.fillStyle = state.color;
                ctx.globalAlpha = 0.7;
                ctx.fill();
                
                // Connecting lines
                if (i > 0) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    const prevAngle = ((i-1) / complexity) * Math.PI * 2 + time * movement * 0.2;
                    const prevX = centerX + Math.cos(prevAngle) * radius * 0.5;
                    const prevY = centerY + Math.sin(prevAngle) * radius * 0.5;
                    ctx.lineTo(prevX, prevY);
                    ctx.strokeStyle = state.color;
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                }
            }
        }

        function drawTriangles(time, centerX, centerY, size) {
            const complexity = state.complexity;
            const movement = state.movement;
            
            for (let i = 0; i < complexity; i++) {
                const angle = (i / complexity) * Math.PI * 2 + time * movement * 0.2;
                const radius = size * (0.3 + 0.7 * (i / complexity));
                const x = centerX + Math.cos(angle) * radius * 0.5;
                const y = centerY + Math.sin(angle) * radius * 0.5;
                
                const triangleSize = size * (0.1 + 0.05 * Math.sin(time + i));
                
                ctx.beginPath();
                ctx.moveTo(x, y - triangleSize);
                ctx.lineTo(x - triangleSize * 0.866, y + triangleSize * 0.5);
                ctx.lineTo(x + triangleSize * 0.866, y + triangleSize * 0.5);
                ctx.closePath();
                
                ctx.fillStyle = state.color;
                ctx.globalAlpha = 0.7;
                ctx.fill();
            }
        }

        function drawSquares(time, centerX, centerY, size) {
            const complexity = state.complexity;
            const movement = state.movement;
            
            for (let i = 0; i < complexity; i++) {
                const angle = (i / complexity) * Math.PI * 2 + time * movement * 0.2;
                const radius = size * (0.3 + 0.7 * (i / complexity));
                const x = centerX + Math.cos(angle) * radius * 0.5;
                const y = centerY + Math.sin(angle) * radius * 0.5;
                
                const squareSize = size * (0.1 + 0.05 * Math.sin(time + i));
                
                ctx.fillStyle = state.color;
                ctx.globalAlpha = 0.7;
                ctx.fillRect(x - squareSize/2, y - squareSize/2, squareSize, squareSize);
            }
        }

        function drawHexagons(time, centerX, centerY, size) {
            const complexity = state.complexity;
            const movement = state.movement;
            
            for (let i = 0; i < complexity; i++) {
                const angle = (i / complexity) * Math.PI * 2 + time * movement * 0.2;
                const radius = size * (0.3 + 0.7 * (i / complexity));
                const x = centerX + Math.cos(angle) * radius * 0.5;
                const y = centerY + Math.sin(angle) * radius * 0.5;
                
                const hexSize = size * (0.1 + 0.05 * Math.sin(time + i));
                
                ctx.beginPath();
                for (let j = 0; j < 6; j++) {
                    const hexAngle = j * Math.PI / 3;
                    const hexX = x + Math.cos(hexAngle) * hexSize;
                    const hexY = y + Math.sin(hexAngle) * hexSize;
                    if (j === 0) {
                        ctx.moveTo(hexX, hexY);
                    } else {
                        ctx.lineTo(hexX, hexY);
                    }
                }
                ctx.closePath();
                
                ctx.fillStyle = state.color;
                ctx.globalAlpha = 0.7;
                ctx.fill();
            }
        }

        function drawFibers(time, centerX, centerY, size) {
            const complexity = state.complexity * 2;
            const movement = state.movement;
            
            ctx.lineWidth = 2;
            
            for (let i = 0; i < complexity; i++) {
                const angle = (i / complexity) * Math.PI * 2;
                const radius = size * (0.2 + 0.6 * (i / complexity));
                
                const noise = Math.sin(time * movement * 0.5 + i * 0.5) * 0.2;
                
                const x1 = centerX + Math.cos(angle) * radius;
                const y1 = centerY + Math.sin(angle) * radius;
                const x2 = centerX + Math.cos(angle + noise) * (radius + 30);
                const y2 = centerY + Math.sin(angle + noise) * (radius + 30);
                
                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, state.color);
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = gradient;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
            }
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>